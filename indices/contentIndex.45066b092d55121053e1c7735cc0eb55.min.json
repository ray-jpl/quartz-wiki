{"/":{"title":"Raymond's Wiki","content":"\nHi, I'm Raymond! I'm a computer science student at UNSW.\n\nThis is my personal notes/wiki website. Learning new things is something that I love doing but keeping track of the notes I write during learning is difficult. Often times I would have information split between various platforms and they all felt somewhat inflexible at connecting ideas smoothly. I discovered [Obsidian](https://obsidian.md/) and the [Zettelkasten method](https://zettelkasten.de/introduction/) for taking notes that seemed to be an effective approach to build a comprehensive knowledge database.\n\nThis wiki will contain notes on Computer Science/Software Engineering concepts and anything else I'm learning about. These are my [evergreen notes](https://notes.andymatuschak.org/Evergreen_notes) so I hope to be constantly growing this database over time. \n\nIf youre interested in learning more about Obsidian or how I set this website up just visit [[notes/Obsidian Notes]].\n\n\nTo navigate between topics just click on the links below or just any node on the graph.\n\n## Contents\n- [[notes/Obsidian Notes]]\n- [[notes/Kafka]]\n- [[notes/LDAP]]\n- [[]]\n\n## Data Structures \u0026 Algorithms\n- [[notes/Topological Sort]]\n- [[notes/Binary Tree]]","lastmodified":"2023-05-11T11:14:47.327781883Z","tags":[]},"/notes/Binary-Search-Tree":{"title":"Binary Search Tree","content":"\nBinary Search Trees(BST) are [[notes/Binary Tree]] that have a left subtree that only contains values smaller than the root node, the right subtree only contains values greater than the root node. \n![[files/bst.png]]\n\n## References","lastmodified":"2023-05-11T11:14:47.331781891Z","tags":["Binary Search Tree","Binary Tree"]},"/notes/Binary-Search-Tree-Inorder-Traversal":{"title":"Binary Search Tree - In-Order Traversal","content":"\nInorder search for a [[notes/Binary Search Tree]] searches nodes from lowest to highest.\n\nAs Binary search trees are ordered in a way that all nodes in the left subtree contain a lower value than the current node. We can use this property and traverse to the leftmost node in the tree which will be the beginning of our search.\n\nGiven that the current node is the smallest then we must traverse through its right subtree in order to find the next larger nodes. Once the right subtree is exhausted we go up a level/depth and repeat.\n\n\n## Example\n[Leetcode 94 - Binary Tree Inorder Traversal] \n```java {title=Leetcode 94}\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n\n */\n\n// The iterative solution can utilise a stack to keep track of the parent nodes\nclass Solution {\n    public List\u003cInteger\u003e inorderTraversal(TreeNode root) {\n        List\u003cInteger\u003e list = new ArrayList\u003cInteger\u003e();\n        if(root == null) return list;\n  \n        Stack\u003cTreeNode\u003e stack = new Stack\u003c\u003e();\n\n        while(root != null || !stack.empty()){\n            while(root != null){\n                // Go to the leftmost node possible\n                stack.push(root);\n                root = root.left;\n            }\n            // Once leftmost is reached traverse right subtree and then repeat\n            root = stack.pop();\n            list.add(root.val);\n            root = root.right;\n        }\n        return list;\n    }\n}\n\n// Recursive solution follows same logic\n// Go as far left as you can then add the node,\n// Then traverse right subtree in a similar manner\nclass Solution {\n    List\u003cInteger\u003e list = new ArrayList\u003cInteger\u003e();\n    public List\u003cInteger\u003e inorderTraversal(TreeNode root) {\n        traverse(root);\n        return list;\n    }\n\n    public void traverse(TreeNode root) {\n        if (root != null) {\n            traverse(root.left);\n            list.add(root.val);\n            traverse(root.right);\n        }\n    }\n        \n}\n```\n\n## Time Complexity\nBoth solutions have to iterate over every node in the tree and therefore there it has O(N) worst case time complexity. \n\n## Space Complexity\nFor the iterative solution the Stack is the only data structure and it has a space complexity of O(H) where H is the height of the tree. In the worst case has an O(N) space complexity where the entire tree is just leftnodes. \n\nFor the recursive case if you do not count the call stack then it has a space complexity of O(1), otherwise the space complexity is the same as the iterative solution. \n\n## References","lastmodified":"2023-05-11T11:14:47.331781891Z","tags":["Binary Search Tree","Binary Tree"]},"/notes/Binary-Tree":{"title":"Binary Tree","content":"\n## References","lastmodified":"2023-05-11T11:14:47.331781891Z","tags":["Binary Tree"]},"/notes/Binary-Tree-Level-Order-Traversal":{"title":"Binary Tree - Level Order Traversal","content":"\nLevel Order Traversal is essentially storing the nodes of each level/depth of the [[notes/Binary Tree]].\n\nThis can be performed iteratively using a Queue datastructure.\nThe general idea is to populate the queue with the nodes of the current level.\nNow that the queue has all the nodes on that level, lets say N nodes, we just need to dequeue the next N nodes from the queue.\nWhile we dequeue each node we can add its child nodes to the queue.\nOnce N nodes have been dequeued the queue will only be full of the nodes in the next level and then the cycle repeats. \n \n\n## Example\n[Leetcode 102 - Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)\n```java {title=\"Leetcode 102\"}\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n\n    public List\u003cList\u003cInteger\u003e\u003e levelOrder(TreeNode root) {\n        List\u003cList\u003cInteger\u003e\u003e result = new ArrayList();\n        if (root == null) {\n            return result;\n        }\n        Queue\u003cTreeNode\u003e treeQueue = new LinkedList\u003c\u003e();\n        treeQueue.add(root);\n        while (!treeQueue.isEmpty()) {\n            int levelsize = treeQueue.size(); // Get size of Level\n\n            List\u003cInteger\u003e levelList = new ArrayList(); // Stores all nodes on cur Level\n\n            for (int i = 0; i \u003c levelsize; i++) {\n                TreeNode node = treeQueue.poll();\n                if (node.left != null) treeQueue.add(node.left);\n                if (node.right != null) treeQueue.add(node.right);\n                levelList.add(node.val);\n            }\n            result.add(levelList);\n        }\n\n        return result;\n    }\n\n}\n```\n\n## Time Complexity\nThe algorithm involves traversing through all nodes in the tree using the Queue. \nQueue operations have O(1) time complexity. Therefore the while loop has a time complexity of O(N) as it involves adding and dequeuing a total of N nodes using the nested for-loop. \n\n## Space Complexity\nThe algorithm uses a queue data structure that store the nodes in the tree and therefore has a space complexity of O(N).\n\n\n## References","lastmodified":"2023-05-11T11:14:47.331781891Z","tags":["Binary Tree"]},"/notes/Degree":{"title":"Degree","content":"\n## Degree\nThe **degree** of a node is the number of edges connected to the node.\n\nThe **maximum degree** of a graph is the highest degree of all nodes.\n![[files/algorithm/graphDegree.png]]\n\n\n### Directed Graphs\nFor directed graphs, node can have an **indegree** and an **outdegree** which corresponds to the number of incoming and outgoing edges respectively.\n\n### Indegree \n- The number of incoming edges\n![[files/algorithm/graphDegreeDirected.png]] ^fb4996\n\n### Outdegree\n- The number of outgoing edges\n\n## References\nhttps://www.interviewcake.com/concept/java/topological-sort","lastmodified":"2023-05-11T11:14:47.331781891Z","tags":["Graph Theory"]},"/notes/Directory-Information-Tree-DIT":{"title":"Directory Information Tree","content":"\nLDAP directories are organized in a hierarchical tree structure, similar to the directory structure of a file system. This structure is also known as the Directory Information Tree (DIT). At the top of the tree is the root node, and below that are branches and sub-branches that represent the various objects and attributes in the directory.\n\nEach object in the directory is represented by an entry in the tree, and each entry is identified by a unique name called a distinguished name (DN). The distinguished name of an entry is composed of the names of all the nodes (or branches) that lead to that entry, starting from the root of the tree.\n\nFor example, suppose we have an LDAP directory that contains information about employees in a company. The top-level node in the tree might be the organization's name, followed by sub-nodes for departments, teams, and individual employees. The distinguished name for an employee named \"John Smith\" in the \"Sales\" department might look something like this:\n\ncn=John Smith,ou=Sales,ou=Departments,o=MyCompany,c=US\n\nHere, \"cn\" stands for \"common name\", \"ou\" stands for \"organizational unit\", \"o\" stands for \"organization\", and \"c\" stands for \"country\". These are all examples of attributes that can be used to identify and categorize entries in the directory. LDAP DNs also ascend the tree from left to right, Here the John Smith is directly under Sales and Sales is part of Departments and so on.\n\nIt is common practice to refer to the leftmost component of an entry's DN as the RDN for that entry. In the above example, the RDN would be cn=John Smith.\n\nThe distinguished name of an entry is important because it provides a unique identifier that can be used to retrieve or modify the entry. When a client application wants to access an entry in the directory, it sends a request to the LDAP server that includes the distinguished name of the entry it wants to access.\n\n\n\n## References\n- https://ldap.com/ldap-dns-and-rdns/","lastmodified":"2023-05-11T11:14:47.331781891Z","tags":["LDAP","DIT"]},"/notes/Kafka":{"title":"Kafka","content":"\n## Event Streaming\n\"Event streaming is the practice of capturing data in real-time from event sources like databases, sensors, mobile devices, cloud services, and software applications in the form of streams of events; storing these event streams durably for later retrieval; manipulating, processing, and reacting to the event streams in real-time as well as retrospectively; and routing the event streams to different destination technologies as needed. Event streaming thus ensures a continuous flow and interpretation of data so that the right information is at the right place, at the right time.\"\n\nKafka is a distributed system consisting of servers and clients that communicate via a high-performance TCP network protocol. It can be deployed on hardware, virtual machines, and containers in on-premise as well as cloud environments.\n\n\n## Concept\nWhen an event occurs the producer creates a new record/event/message\n\n### Producers\n-   Receives updates and writes these 'records' into a queue\n-   This queue is usually referred to as a Kafka Topic\n\n### Topics\n-   Messages in a Kafka topic are not delete when they are consumed/read\n\t-   Can use various policies to manage the messages\n\t-   Retention Policy\n\t\t-   Can set a rule to delete messages older than 24hrs\n\t\n\t-   Can also store older messages in Fault tolerant, persistent storage (Hard drive)\n\t\t-   Can be useful to recover previous messages if a Broker goes down\n\n-   Topics can be organised into partitions\n\t-   This distributed placement of your data is very important for scalability because it allows client applications to both read and write the data from/to many brokers at the same time. When a new event is published to a topic, it is actually appended to one of the topic's partitions\n\t-   Kafka guarantees that any consumer of a given topic-partition will always read that partition's events in exactly the same order as they were written\n\n### Broker\n-   Brokers are the servers that these partitions run on\n-   To make your data fault-tolerant and highly-available, every topic can be replicated, even across geo-regions or datacenters, so that there are always multiple brokers that have a copy of the data just in case things go wrong, you want to do maintenance on the brokers, and so on. A common production setting is a replication factor of 3\n\n### Consumer\n-   Consumers consume the messages in the queue\n-   Listen for updates in real time\n-   Consumers are very lightweight and should be able to create many without affecting performance\n-   Use Offsets (pointers) to keep track of which latest message they have read\n\n![kafka](files/kafka.png)\n\n\n## References\n- https://kafka.apache.org/intro\n- [Kafka in 100 seconds](https://youtu.be/uvb00oaa3k8)\n- [Apache Kafka in 6 minutes](https://youtu.be/Ch5VhJzaoaI)\n- [Why is Kafka so Fast](https://www.youtube.com/watch?v=UNUz1-msbOM)\n- [What is Kafka?](https://www.youtube.com/watch?v=aj9CDZm0Glc)","lastmodified":"2023-05-11T11:14:47.331781891Z","tags":["Kafka"]},"/notes/LDAP":{"title":"LDAP","content":"\nLightweight Directory Access Protocol (LDAP) is a vendor-neutral protocol used for accessing and maintaining distributed directory information services. A directory service is like a database that stores information about network resources, such as users, computers, printers, and other devices.\n\nLDAP is commonly used to provide authentication and authorization services for networked resources. For example, when you log in to a computer that's part of a domain, the computer might use LDAP to check your username and password against the directory service to determine whether you're authorized to access the network.\n\nLDAP is a client-server protocol, which means that there's a client application that sends requests to a server application to access the directory information. The client and server communicate using TCP/IP, and LDAP requests and responses are usually transmitted over port 389 or 636 (if using SSL).\n\nLDAP directories are organized into a hierarchical tree structure, called [[notes/Directory Information Tree (DIT)]], where each node in the tree represents an object, such as a user or a group. Each object is identified by a unique name called a distinguished name (DN), which consists of a series of attributes separated by commas. For example, the DN for a user might be \"cn=John Doe, ou=Users, dc=example, dc=com\".\n\n\n\n\nLDAP uses a query language called LDAP Query Language (LDAPQL) to search and retrieve information from the directory. LDAP queries are similar to SQL queries, but they use a different syntax and support different search filters and operations.\n\n## References\n- https://www.onelogin.com/learn/what-is-ldap","lastmodified":"2023-05-11T11:14:47.331781891Z","tags":["LDAP"]},"/notes/Obsidian-Notes":{"title":"Obsidian Notes","content":"\n## Setup\nTo setup Obsidian Notes just install [Obsidian](https://obsidian.md/) and you can immediately start taking notes. There are many different ways to setup your Obsidian editor and many plugins to use in order to customise your experience. I recommend watching [this video](https://youtu.be/E6ySG7xYgjY) first to get an idea but there are tonnes of YouTube tutorials out there.\n\nIf you wanted to deploy your notes as a website, you don't have to pay for the [Obsidian Publish](https://obsidian.md/publish) service but it may be easier if you have less technical knowledge. Otherwise I used [Quartz](https://quartz.jzhao.xyz/) hosted using Github Pages which is very beginner friendly with comprehensive instructions but also highly customisable if you want to put in the effort. However there are other plugins available on the internet that seem to be popular as well. \n\n\n","lastmodified":"2023-05-11T11:14:47.331781891Z","tags":["Obsidian","Quartz"]},"/notes/Topological-Sort":{"title":"Topological Sort","content":"\n## Topological Sort\nThe topological sort algorithm takes a directed graph and returns an array of the nodes where each node appears before all the nodes it points to. \n\n### Example 1\n\n![topsort_ex1](files/TopologicalSort/topSort_ex1.png)\n\n![topsort_ex1_ordered}](files/TopologicalSort/topSort_ex1_ordered.png)\nGraphs can have more than one valid topological ordering.\nThis graph has valid ordering of \\[1,2,3,4,5\\]  or \\[1,3,2,4,5\\]\n\n## Algorithm\nTo produce a topological ordering for this directed graph we have to find the nodes with an [[notes/Degree#Indegree]] of zero. Nodes with an indegree of zero come first.\n\n![topsort_ex2](files/TopologicalSort/topSort_ex2.png)\n\n![topsort_ex2_1](files/TopologicalSort/topSort_ex2_1.png)\n\n\n![topsort_ex2_2](files/TopologicalSort/topSort_ex2_2.png)\n\n![topsort_ex2_3](files/TopologicalSort/topSort_ex2_3.png)\n\n![topsort_ex2_4](files/TopologicalSort/topSort_ex2_4.png)\n\n![topsort_ex2_5](files/TopologicalSort/topSort_ex2_5.png)\n\n\n## Implementation\n1. Identify a node with no incoming edges.\n2. Add that node to the ordering.\n3. \"Remove\" it from the graph by decrementing indegree of neighbours\n5. Repeat.\n\n\nTopological Sort can be useful to find cycles in directed graphs as if a cycle exists there will always be a node with at least one incoming edge. \n![cycle](files/TopologicalSort/graphCycle.png)\n\n### Example\n[Leetcode 207 - Course Schedule](https://leetcode.com/problems/course-schedule/) \n```java {title=\"Leetcode 207\"}\nclass Solution {\n\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        // Topological sort\n        // Prereq array is all the edges\n\n\t\tArrayList\u003cArrayList\u003cInteger\u003e\u003e nodes = new ArrayList\u003cArrayList\u003cInteger\u003e\u003e(numCourses);\n\n        for (int i = 0; i \u003c numCourses; i++) {\n            nodes.add(new ArrayList\u003cInteger\u003e());\n        }\n\n        int[] degree = new int[numCourses];\n  \n        // Directed Graph, from edge[1] you can access edge[0]\n        for (int[] edge : prerequisites) {\n            nodes.get(edge[1]).add(edge[0]);\n            degree[edge[0]] += 1; //Increment number of incoming edges\n        }\n\n        // For you to pass all courses, all courses must be doable\n        // Courses cant be all doable if there is a cycle in the graph\n        // Therefore there must be a node with zero incoming directed edges\n\n        ArrayList\u003cInteger\u003e topSort = new ArrayList\u003cInteger\u003e();\n\n        for (int i = 0; i \u003c numCourses; i++) {\n            if (degree[i] == 0) {\n                topSort.add(i);\n            }\n        }\n\n        for (int i = 0; i \u003c topSort.size(); i++) {\n            // Get nodes that are connected to current\n            ArrayList\u003cInteger\u003e connectedNodes = nodes.get(topSort.get(i));\n            for (int node : connectedNodes) {\n                // Now that the current node has been recorded the connected nodes are decremented by a degree of one\n                degree[node]--;\n                if (degree[node] == 0) {\n                    // If they are the degree 0 then that means they are next\n                    topSort.add(node);\n                }\n            }\n        }\n\n        // If a cycle was detected then the node that creates the cycle would not have been appended\n        return (topSort.size() == numCourses);\n    }\n}\n```\n\n\n\n## Time Complexity\nLet **V** be the number of Verticies (nodes) and **E** be the number of edges\n\n- Time complexity to determine the indegree for each node is O(E) as we must loop over all edges.\n\n- Then we must loop over all nodes and append all that have an indegree of zero to a list/stack. Appending is constant time so this take O(V).\n\n- Then loop over each node in our list/stack, pop off and decrement the connected edges, therefore O(V)\n\t- Although a loop is used to decrement the edges we won't count edges twice therefore it has an additional total time complexity of O(E). \n\nTherefore total time complexity is O(V+E).\n\n## Space Complexity\nSpace complexity is O(V)\n- Structure to store the integer number of indegrees for each node is O(V).\n- Structure to store all nodes with no incoming edges is O(V) worst case. Worst case all nodes have zero edges\n- Topological ordering result is O(V) worst case as all nodes will be in the ordering at the end if the graph has no cycles.\n\n\n## Uses\n- Can be used to find cycles\n- Can also be used to find order of a procedure where steps may be dependant on each other\n\t- E.g baking a cake\n\n\n\n## References\nhttps://www.interviewcake.com/concept/java/topological-sort","lastmodified":"2023-05-11T11:14:47.331781891Z","tags":["Algorithms","Graph Algorithm"]}}