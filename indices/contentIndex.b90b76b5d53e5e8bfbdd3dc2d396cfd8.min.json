{"/":{"title":"Raymond's Wiki","content":"\nHi, I'm Raymond! I'm a computer science student at UNSW.\n\nThis is my personal notes/wiki website. Learning new things is something that I love doing but keeping track of the notes I write during learning is difficult. Often times I would have information split between Google Drive and OneNote but these platforms feel somewhat inflexible at connecting ideas smoothly. I discovered [Obsidian](https://obsidian.md/) and the [Zettelkasten method](https://zettelkasten.de/introduction/) for taking notes that seemed to be an effective approach to build a comprehensive knowledge database.\n\nThis wiki will contain notes on Computer Science/Software Engineering concepts and anything else I think may be relevant or interesting. These are my [evergreen notes](https://notes.andymatuschak.org/Evergreen_notes) so I hope to be constantly growing this database over time. \n\nIf youre interested in learning more about Obsidian or how I set this website up just visit [[notes/Obsidian Notes]].\n\n\nTo navigate between topics just click on the links below or just any node on the graph.\n\n## Contents\n- [[notes/Obsidian Notes]]\n- [[notes/Kafka]]\n\n## Algorithms\n- [[notes/Topological Sort]]","lastmodified":"2023-03-21T12:41:32.223959551Z","tags":[]},"/notes/Degree":{"title":"Degree","content":"\n## Degree\nThe **degree** of a node is the number of edges connected to the node.\n\nThe **maximum degree** of a graph is the highest degree of all nodes.\n![[files/algorithm/graphDegree.png]]\n\n\n### Directed Graphs\nFor directed graphs, node can have an **indegree** and an **outdegree** which corresponds to the number of incoming and outgoing edges respectively.\n\n### Indegree \n- The number of incoming edges\n![[files/algorithm/graphDegreeDirected.png]] ^fb4996\n\n### Outdegree\n- The number of outgoing edges\n\n## References\nhttps://www.interviewcake.com/concept/java/topological-sort","lastmodified":"2023-03-21T12:41:32.22795951Z","tags":["Graph Theory"]},"/notes/Kafka":{"title":"Kafka","content":"\n## Event Streaming\n\"Event streaming is the practice of capturing data in real-time from event sources like databases, sensors, mobile devices, cloud services, and software applications in the form of streams of events; storing these event streams durably for later retrieval; manipulating, processing, and reacting to the event streams in real-time as well as retrospectively; and routing the event streams to different destination technologies as needed. Event streaming thus ensures a continuous flow and interpretation of data so that the right information is at the right place, at the right time.\"\n\nKafka is a distributed system consisting of servers and clients that communicate via a high-performance TCP network protocol. It can be deployed on hardware, virtual machines, and containers in on-premise as well as cloud environments.\n\n\n## Concept\nWhen an event occurs the producer creates a new record/event/message\n\n### Producers\n-   Receives updates and writes these 'records' into a queue\n-   This queue is usually referred to as a Kafka Topic\n\n### Topics\n-   Messages in a Kafka topic are not delete when they are consumed/read\n\t-   Can use various policies to manage the messages\n\t-   Retention Policy\n\t\t-   Can set a rule to delete messages older than 24hrs\n\t\n\t-   Can also store older messages in Fault tolerant, persistent storage (Hard drive)\n\t\t-   Can be useful to recover previous messages if a Broker goes down\n\n-   Topics can be organised into partitions\n\t-   This distributed placement of your data is very important for scalability because it allows client applications to both read and write the data from/to many brokers at the same time. When a new event is published to a topic, it is actually appended to one of the topic's partitions\n\t-   Kafka guarantees that any consumer of a given topic-partition will always read that partition's events in exactly the same order as they were written\n\n### Broker\n-   Brokers are the servers that these partitions run on\n-   To make your data fault-tolerant and highly-available, every topic can be replicated, even across geo-regions or datacenters, so that there are always multiple brokers that have a copy of the data just in case things go wrong, you want to do maintenance on the brokers, and so on. A common production setting is a replication factor of 3\n\n### Consumer\n-   Consumers consume the messages in the queue\n-   Listen for updates in real time\n-   Consumers are very lightweight and should be able to create many without affecting performance\n-   Use Offsets (pointers) to keep track of which latest message they have read\n\n![kafka](files/kafka.png)\n\n\n## References\n- https://kafka.apache.org/intro\n- [Kafka in 100 seconds](https://youtu.be/uvb00oaa3k8)\n- [Apache Kafka in 6 minutes](https://youtu.be/Ch5VhJzaoaI)\n- [Why is Kafka so Fast](https://www.youtube.com/watch?v=UNUz1-msbOM)\n- [What is Kafka?](https://www.youtube.com/watch?v=aj9CDZm0Glc)","lastmodified":"2023-03-21T12:41:32.22795951Z","tags":["Kafka"]},"/notes/Obsidian-Notes":{"title":"Obsidian Notes","content":"\n## Setup\nTo setup Obsidian Notes just install [Obsidian](https://obsidian.md/) and you can immediately start taking notes. There are many different ways to setup your Obsidian editor and many plugins to use in order to customise your experience. I recommend watching [this video](https://youtu.be/E6ySG7xYgjY) first to get an idea but there are tonnes of YouTube tutorials out there.\n\nIf you wanted to deploy your notes as a website, you don't have to pay for the [Obsidian Publish](https://obsidian.md/publish) service but it may be easier if you have less technical knowledge. Otherwise I used [Quartz](https://quartz.jzhao.xyz/) hosted using Github Pages which is very beginner friendly with comprehensive instructions but also highly customisable if you want to put in the effort. However there are other plugins available on the internet that seem to be popular as well. \n\n\n","lastmodified":"2023-03-21T12:41:32.22795951Z","tags":["Obsidian","Quartz"]},"/notes/Topological-Sort":{"title":"Topological Sort","content":"\n## Topological Sort\nThe topological sort algorithm takes a directed graph and returns an array of the nodes where each node appears before all the nodes it points to. \n\n### Example 1\n\n![topsort_ex1](files/TopologicalSort/topSort_ex1.png)\n\n![topsort_ex1_ordered}](files/TopologicalSort/topSort_ex1_ordered.png)\nGraphs can have more than one valid topological ordering.\nThis graph has valid ordering of \\[1,2,3,4,5\\]  or \\[1,3,2,4,5\\]\n\n## Algorithm\nTo produce a topological ordering for this directed graph we have to find the nodes with an [[notes/Degree#Indegree]] of zero. Nodes with an indegree of zero come first.\n\n![topsort_ex2](files/TopologicalSort/topSort_ex2.png)\n\n![topsort_ex2_1](files/TopologicalSort/topSort_ex2_1.png)\n\n\n![topsort_ex2_2](files/TopologicalSort/topSort_ex2_2.png)\n\n![topsort_ex2_3](files/TopologicalSort/topSort_ex2_3.png)\n\n![topsort_ex2_4](files/TopologicalSort/topSort_ex2_4.png)\n\n![topsort_ex2_5](files/TopologicalSort/topSort_ex2_5.png)\n\n\n## Implementation\n1. Identify a node with no incoming edges.\n2. Add that node to the ordering.\n3. \"Remove\" it from the graph by decrementing indegree of neighbours\n5. Repeat.\n\n\nTopological Sort can be useful to find cycles in directed graphs as if a cycle exists there will always be a node with at least one incoming edge. \n![cycle](files/TopologicalSort/graphCycle.png)\n\n### Example\n[Leetcode 207 - Course Schedule](https://leetcode.com/problems/course-schedule/) \n```java {title=\"Leetcode 207\"}\nclass Solution {\n\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        // Topological sort\n        // Prereq array is all the edges\n\n\t\tArrayList\u003cArrayList\u003cInteger\u003e\u003e nodes = new ArrayList\u003cArrayList\u003cInteger\u003e\u003e(numCourses);\n\n        for (int i = 0; i \u003c numCourses; i++) {\n            nodes.add(new ArrayList\u003cInteger\u003e());\n        }\n\n        int[] degree = new int[numCourses];\n  \n        // Directed Graph, from edge[1] you can access edge[0]\n        for (int[] edge : prerequisites) {\n            nodes.get(edge[1]).add(edge[0]);\n            degree[edge[0]] += 1; //Increment number of incoming edges\n        }\n\n        // For you to pass all courses, all courses must be doable\n        // Courses cant be all doable if there is a cycle in the graph\n        // Therefore there must be a node with zero incoming directed edges\n\n        ArrayList\u003cInteger\u003e topSort = new ArrayList\u003cInteger\u003e();\n\n        for (int i = 0; i \u003c numCourses; i++) {\n            if (degree[i] == 0) {\n                topSort.add(i);\n            }\n        }\n\n        for (int i = 0; i \u003c topSort.size(); i++) {\n            // Get nodes that are connected to current\n            ArrayList\u003cInteger\u003e connectedNodes = nodes.get(topSort.get(i));\n            for (int node : connectedNodes) {\n                // Now that the current node has been recorded the connected nodes are decremented by a degree of one\n                degree[node]--;\n                if (degree[node] == 0) {\n                    // If they are the degree 0 then that means they are next\n                    topSort.add(node);\n                }\n            }\n        }\n\n        // If a cycle was detected then the node that creates the cycle would not have been appended\n        return (topSort.size() == numCourses);\n    }\n}\n```\n\n\n\n## Time Complexity\nLet **V** be the number of Verticies (nodes) and **E** be the number of edges\n\n- Time complexity to determine the indegree for each node is O(E) as we must loop over all edges.\n\n- Then we must loop over all nodes and append all that have an indegree of zero to a list/stack. Appending is constant time so this take O(V).\n\n- Then loop over each node in our list/stack, pop off and decrement the connected edges, therefore O(V)\n\t- Although a loop is used to decrement the edges we won't count edges twice therefore it has an additional total time complexity of O(E). \n\nTherefore total time complexity is O(V+E).\n\n## Space Complexity\nSpace complexity is O(V)\n- Structure to store the integer number of indegrees for each node is O(V).\n- Structure to store all nodes with no incoming edges is O(V) worst case. Worst case all nodes have zero edges\n- Topological ordering result is O(V) worst case as all nodes will be in the ordering at the end if the graph has no cycles.\n\n\n## Uses\n- Can be used to find cycles\n- Can also be used to find order of a procedure where steps may be dependant on each other\n\t- E.g baking a cake\n\n\n\n## References\nhttps://www.interviewcake.com/concept/java/topological-sort","lastmodified":"2023-03-21T12:41:32.22795951Z","tags":["Algorithms","Graph Algorithm"]}}